<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NYC Trees & Income by ZIP</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <!-- PT Serif for tooltips -->
  <link
    href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&display=swap"
    rel="stylesheet"
  />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    header {
      padding: 10px 14px;
      background: #f7f7f7;
      border-bottom: 1px solid #ddd;
      font-size: 16px;
      font-weight: 600;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 8px 14px;
      border-bottom: 1px solid #eee;
      font-size: 14px;
      flex-wrap: wrap;
    }

    .controls label {
      font-weight: 500;
    }

    .controls select,
    .controls input {
      padding: 4px 6px;
      font-size: 14px;
    }

    .maps-container {
      flex: 1;
      display: flex;
      flex-direction: row;
      min-height: 0;
    }

    .map-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-left: 1px solid #ddd;
    }

    .map-wrapper:first-child {
      border-left: none;
    }

    .map {
      flex: 1;
    }

    .leaflet-tooltip {
      font-family: "PT Serif", serif;
    }

    .leaflet-tooltip h4 {
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 700;
    }

    .leaflet-tooltip p {
      margin: 0;
      font-size: 12px;
      line-height: 1.3;
    }
  </style>
</head>

<body>
<div id="app">
  <header>TEST VERSION – IF YOU SEE THIS, IT’S THE NEW CODE</header>

  <div class="controls">
    <label for="zipSelect">ZIP code list:</label>
    <select id="zipSelect">
      <option value="ALL">(All ZIP codes)</option>
      <!-- JS will populate -->
    </select>

    <label for="zipSearch">Search ZIP:</label>
    <input id="zipSearch" type="text" placeholder="Type ZIP (e.g. 10016)" maxlength="5" />
  </div>

  <div class="maps-container">
    <div class="map-wrapper">
      <div id="mapTrees" class="map"></div>
    </div>
    <div class="map-wrapper">
      <div id="mapIncome" class="map"></div>
    </div>
  </div>
</div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- d3 for CSV + color scales -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>

<script>
  const NYC_CENTER = [40.7128, -74.0060];
  const NYC_ZOOM = 10;

  // ZIP field from your GeoJSON
  function getZipFromFeature(feature) {
    const raw = feature?.properties?.postalCode;
    if (raw == null) return null;
    return raw.toString().padStart(5, "0");
  }

  const mapTrees = L.map("mapTrees", { zoomControl: false }).setView(NYC_CENTER, NYC_ZOOM);
  const mapIncome = L.map("mapIncome", { zoomControl: false }).setView(NYC_CENTER, NYC_ZOOM);

  // nice light gray NYC backdrop (Carto Positron)
  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    {
      maxZoom: 18,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }
  ).addTo(mapTrees);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    {
      maxZoom: 18,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }
  ).addTo(mapIncome);

  let geojsonLayerTrees;
  let geojsonLayerIncome;
  let dataByZip = {};
  let treeColorScale, incomeColorScale;
  let selectedZip = null; // currently highlighted ZIP

  Promise.all([
    d3.json("nyc_zipcodes.geojson"),
    d3.csv("Tree Data Per Zip.csv")
  ])
  .then(initMaps)
  .catch(err => console.error("Error loading data:", err));

  function initMaps([geojson, csvData]) {
    // Build lookup from CSV (using your column names)
    dataByZip = {};
    csvData.forEach(d => {
      const zip = d.postcode ? d.postcode.toString().padStart(5, "0") : null;
      if (!zip) return;

      dataByZip[zip] = {
        zip,
        treesPer100: +d["Trees per 100 Residents"],
        treeCount: +d["Tree Count"],
        population: +d["Population"],
        medianIncome: +d["Median Income"],
        goodPct: d["Percent good"] ? +d["Percent good"] : null,
        fairPct: d["Percent fair"] ? +d["Percent fair"] : null,
        poorPct: d["Percent poor"] ? +d["Percent poor"] : null,
      };
    });

    const treeValues = Object.values(dataByZip)
      .map(d => d.treesPer100)
      .filter(v => !isNaN(v));
    const incomeValues = Object.values(dataByZip)
      .map(d => d.medianIncome)
      .filter(v => !isNaN(v));

    const treeExtent = d3.extent(treeValues);
    const incomeExtent = d3.extent(incomeValues);

    treeColorScale = d3.scaleSequential()
      .domain(treeExtent)
      .interpolator(d3.interpolateGreens);

    const pinkStart = d3.rgb("#fde0dd");
    const pinkEnd = d3.rgb("#c51b8a");
    const pinkInterp = d3.interpolate(pinkStart, pinkEnd);

    incomeColorScale = d3.scaleSequential()
      .domain(incomeExtent)
      .interpolator(pinkInterp);

    populateZipDropdown();

    geojsonLayerTrees = L.geoJSON(geojson, {
      style: styleTrees,
      onEachFeature: (feature, layer) => {
        attachTooltip(feature, layer, "trees");
        attachHoverInteractions(layer, "trees");
      }
    }).addTo(mapTrees);

    geojsonLayerIncome = L.geoJSON(geojson, {
      style: styleIncome,
      onEachFeature: (feature, layer) => {
        attachTooltip(feature, layer, "income");
        attachHoverInteractions(layer, "income");
      }
    }).addTo(mapIncome);

    const bounds = geojsonLayerTrees.getBounds();
    mapTrees.fitBounds(bounds);
    mapIncome.fitBounds(bounds);
  }

  // ---------- STYLES & HIGHLIGHT ----------
  function styleBase(feature, variant) {
    const zip = getZipFromFeature(feature);
    const d = zip && dataByZip[zip];

    let fillColor = "#cccccc";
    if (d) {
      if (variant === "trees" && treeColorScale) {
        fillColor = treeColorScale(d.treesPer100);
      }
      if (variant === "income" && incomeColorScale) {
        fillColor = incomeColorScale(d.medianIncome);
      }
    }

    const isSelected = !selectedZip || zip === selectedZip;

    return {
      weight: isSelected ? 1.5 : 0.7,
      opacity: isSelected ? 1 : 0.3,
      color: isSelected ? "#333" : "#aaaaaa",
      fillOpacity: isSelected ? 0.85 : 0.15,
      fillColor
    };
  }

  function styleTrees(feature) {
    return styleBase(feature, "trees");
  }

  function styleIncome(feature) {
    return styleBase(feature, "income");
  }

  // ---------- TOOLTIP ----------
  function attachTooltip(feature, layer, variant) {
    const zip = getZipFromFeature(feature);
    const d = zip && dataByZip[zip];

    if (!d) {
      layer.bindTooltip(`<h4>ZIP Code: ${zip || "Unknown"}</h4><p>No data</p>`, {
        sticky: true
      });
      return;
    }

    const numFmt = d3.format(",.0f");
    const incomeFmt = d3.format(",.0f");
    const oneDec = d3.format(".1f");

    let html;

    if (variant === "trees") {
      // Tree map: NO median income line
      html = `
        <h4>ZIP Code: ${d.zip}</h4>
        <p>
          Trees per 100 Residents: <strong>${oneDec(d.treesPer100)}</strong><br/>
          Number of Trees: <strong>${numFmt(d.treeCount)}</strong><br/>
          Population: <strong>${numFmt(d.population)}</strong><br/>
          ${d.goodPct != null ? `Trees in Good Health: <strong>${oneDec(d.goodPct)}%</strong><br/>` : ""}
          ${d.fairPct != null ? `Trees in Fair Health: <strong>${oneDec(d.fairPct)}%</strong><br/>` : ""}
          ${d.poorPct != null ? `Trees in Poor Health: <strong>${oneDec(d.poorPct)}%</strong>` : ""}
        </p>
      `;
    } else {
      // Income map: ONLY median income
      html = `
        <h4>ZIP Code: ${d.zip}</h4>
        <p>
          Median Household Income: <strong>$${incomeFmt(d.medianIncome)}</strong>
        </p>
      `;
    }

    layer.bindTooltip(html, { sticky: true, direction: "auto" });
  }

  // ---------- HOVER + CLICK ----------
  function attachHoverInteractions(layer, variant) {
    layer.on({
      mouseover: function (e) {
        const l = e.target;
        l.setStyle({
          weight: 2,
          color: "#000",
          fillOpacity: 0.95
        });
        if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
          l.bringToFront();
        }
      },
      mouseout: function (e) {
        if (variant === "trees" && geojsonLayerTrees) {
          geojsonLayerTrees.resetStyle(e.target);
        } else if (geojsonLayerIncome) {
          geojsonLayerIncome.resetStyle(e.target);
        }
      },
      click: function (e) {
        const feature = e.target.feature;
        const zip = getZipFromFeature(feature);
        if (!zip) return;

        const select = document.getElementById("zipSelect");

        // If clicking same ZIP again → unselect & zoom out
        if (selectedZip === zip) {
          selectedZip = null;
          select.value = "ALL";
          resetView();
        } else {
          select.value = zip;
          zoomToZip(zip); // zoomToZip will set selectedZip
        }
      }
    });
  }

  // ---------- DROPDOWN & SEARCH ----------
  function populateZipDropdown() {
    const select = document.getElementById("zipSelect");
    const zips = Object.keys(dataByZip).sort();
    zips.forEach(zip => {
      const opt = document.createElement("option");
      opt.value = zip;
      opt.textContent = zip;
      select.appendChild(opt);
    });

    select.addEventListener("change", () => {
      const value = select.value;
      if (value === "ALL") {
        selectedZip = null;
        resetView();
      } else {
        zoomToZip(value);
      }
    });

    setupZipSearch();
  }

  function setupZipSearch() {
    const searchInput = document.getElementById("zipSearch");
    const select = document.getElementById("zipSelect");

    // Filter dropdown options as you type
    searchInput.addEventListener("input", () => {
      const term = searchInput.value.trim();
      for (let i = 0; i < select.options.length; i++) {
        const opt = select.options[i];
        if (opt.value === "ALL") continue;
        opt.hidden = term && !opt.value.includes(term);
      }
    });

    // When user types full ZIP and presses Enter / leaves field
    searchInput.addEventListener("change", () => {
      const val = searchInput.value.trim();
      if (!val) return;
      const opt = Array.from(select.options).find(o => o.value === val);
      if (opt) {
        select.value = val;
        zoomToZip(val);
      }
    });
  }

  function resetView() {
    mapTrees.setView(NYC_CENTER, NYC_ZOOM);
    mapIncome.setView(NYC_CENTER, NYC_ZOOM);

    if (geojsonLayerTrees) geojsonLayerTrees.setStyle(styleTrees);
    if (geojsonLayerIncome) geojsonLayerIncome.setStyle(styleIncome);

    const select = document.getElementById("zipSelect");
    const searchInput = document.getElementById("zipSearch");
    if (searchInput) searchInput.value = "";
    if (select) {
      for (let i = 0; i < select.options.length; i++) {
        select.options[i].hidden = false;
      }
    }
  }

  function zoomToZip(zip) {
    selectedZip = zip;

    if (!geojsonLayerTrees) return;

    let targetLayer = null;
    geojsonLayerTrees.eachLayer(layer => {
      const fZip = getZipFromFeature(layer.feature);
      if (fZip === zip) targetLayer = layer;
    });

    if (!targetLayer) return;

    const bounds = targetLayer.getBounds();
    const options = { maxZoom: 13, padding: [10, 10] };
    mapTrees.fitBounds(bounds, options);
    mapIncome.fitBounds(bounds, options);

    // re-style to apply highlight
    geojsonLayerTrees.setStyle(styleTrees);
    geojsonLayerIncome.setStyle(styleIncome);
  }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NYC Trees & Income by ZIP</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <!-- PT Serif for tooltips -->
  <link
    href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&display=swap"
    rel="stylesheet"
  />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

.map-title {
  text-align: center;
  font-family: "PT Serif", serif;
  font-size: 24px;
  font-weight: 700;
  margin: 0;
  padding: 16px 0 10px 0;
  background: #ffffff !important;   /* force white */
  display: block;
}

    /* Dropdown list (autocomplete) */
.zip-suggestions,
.zip-suggestions .suggestion,
.zip-suggestions .no-match {
  font-family: "PT Serif", serif !important;
  font-size: 20px;
}

    .controls input::placeholder {
  font-family: "PT Serif", serif !important;
  font-size: 20px;
}

.controls label,
.controls input {
  font-family: "PT Serif", serif !important;
  font-size: 20px;
}
    
    #app,
.maps-container,
.map-wrapper {
  background: #ffffff !important;   /* force white for the whole map area */
}

    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* Top controls only, no title */
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 14px;
      border-bottom: 1px solid #eee;
      font-size: 14px;
      flex-wrap: wrap;
      background: #f7f7f7;
    }

    .controls label {
      font-weight: 500;
    }

    .controls input {
      padding: 4px 6px;
      font-size: 14px;
    }

    .zip-search-wrapper {
      position: relative;
      display: inline-block;
      min-width: 150px;
    }

    .zip-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #ffffff;
      border: 1px solid #ccc;
      border-top: none;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
    }

    .zip-suggestions .suggestion {
      padding: 4px 8px;
      cursor: pointer;
    }

    .zip-suggestions .suggestion:hover {
      background: #f0f0f0;
    }

    .zip-suggestions .no-match {
      padding: 4px 8px;
      color: #777;
    }

    .maps-container {
      flex: 1;
      display: flex;
      flex-direction: row;
      min-height: 0;
    }

    .map-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-left: 1px solid #ddd;
    }

    .map-wrapper:first-child {
      border-left: none;
    }

    .map {
      flex: 1;
    }

    .leaflet-tooltip {
      font-family: "PT Serif", serif;
    }

    .leaflet-tooltip h4 {
      margin: 0 0 4px 0;
      font-size: 14px;
      font-weight: 700;
    }

    .leaflet-tooltip p {
      margin: 0;
      font-size: 12px;
      line-height: 1.3;
    }

    /* hide Leaflet attribution */
    .leaflet-control-attribution {
      display: none !important;
    }
  </style>
</head>

<body>
<div id="app">
  <div class="controls">
    <label for="zipSearch">Find your ZIP code:</label>
    <div class="zip-search-wrapper">
      <input id="zipSearch" type="text" placeholder="Type ZIP (e.g. 10016)" maxlength="5" />
      <div id="zipSuggestions" class="zip-suggestions"></div>
    </div>
  </div>

 <div class="maps-container" style="background:#ffffff;">
  <div class="map-wrapper" style="background:#ffffff;">
    <h2 class="map-title" style="background:#ffffff;">
      Map of Amount of Trees per 100 Residents in Each ZIP Code
    </h2>
    <div id="mapTrees" class="map"></div>
  </div>

  <div class="map-wrapper" style="background:#ffffff;">
    <h2 class="map-title" style="background:#ffffff;">
      Map of Median Household Income in Each ZIP Code
    </h2>
    <div id="mapIncome" class="map"></div>
  </div>
</div>
</div>

<!-- Leaflet JS -->
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<!-- d3 for CSV + color scales -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>

<script>
  const NYC_CENTER = [40.7128, -74.0060];
  const NYC_ZOOM = 9; // used if fullBounds isn't ready yet

  function getZipFromFeature(feature) {
    const raw = feature?.properties?.postalCode;
    if (raw == null) return null;
    return raw.toString().padStart(5, "0");
  }

  const mapTrees = L.map("mapTrees", {
    zoomControl: false,
    attributionControl: false
  }).setView(NYC_CENTER, NYC_ZOOM);

  const mapIncome = L.map("mapIncome", {
    zoomControl: false,
    attributionControl: false
  }).setView(NYC_CENTER, NYC_ZOOM);

  const baseLayerOptions = {
    maxZoom: 18
  };

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    baseLayerOptions
  ).addTo(mapTrees);

  L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
    baseLayerOptions
  ).addTo(mapIncome);

  let geojsonLayerTrees;
  let geojsonLayerIncome;
  let fullBounds = null;   // <-- we'll store the full NYC bounds here

  let dataByZip = {};
  let treeColorScale, incomeColorScale;
  let selectedZip = null;
  let allZips = [];

  Promise.all([
    d3.json("nyc_zipcodes.geojson"),
    d3.csv("Tree Data Per Zip.csv")
  ])
    .then(initMaps)
    .catch(err => console.error("Error loading data:", err));

  function initMaps([geojson, csvData]) {
    dataByZip = {};
    csvData.forEach(d => {
      const zip = d.postcode ? d.postcode.toString().padStart(5, "0") : null;
      if (!zip) return;

      dataByZip[zip] = {
        zip,
        treesPer100: +d["Trees per 100 Residents"],
        treeCount: +d["Tree Count"],
        population: +d["Population"],
        medianIncome: +d["Median Income"],
        goodPct: d["Percent good"] ? +d["Percent good"] : null,
        fairPct: d["Percent fair"] ? +d["Percent fair"] : null,
        poorPct: d["Percent poor"] ? +d["Percent poor"] : null
      };
    });

    allZips = Object.keys(dataByZip).sort();
    setupZipSearch();

    const treeValues = allZips
      .map(z => dataByZip[z].treesPer100)
      .filter(v => !isNaN(v));
    const incomeValues = allZips
      .map(z => dataByZip[z].medianIncome)
      .filter(v => !isNaN(v));

    const treeExtent = d3.extent(treeValues);
    const incomeExtent = d3.extent(incomeValues);

    treeColorScale = d3
      .scaleSequential()
      .domain(treeExtent)
      .interpolator(d3.interpolateGreens);

    const pinkStart = d3.rgb("#fde0dd");
    const pinkEnd = d3.rgb("#c51b8a");
    const pinkInterp = d3.interpolate(pinkStart, pinkEnd);

    incomeColorScale = d3
      .scaleSequential()
      .domain(incomeExtent)
      .interpolator(pinkInterp);

    geojsonLayerTrees = L.geoJSON(geojson, {
      style: styleTrees,
      onEachFeature: (feature, layer) => {
        attachTooltip(feature, layer, "trees");
        attachHoverInteractions(layer, "trees");
      }
    }).addTo(mapTrees);

    geojsonLayerIncome = L.geoJSON(geojson, {
      style: styleIncome,
      onEachFeature: (feature, layer) => {
        attachTooltip(feature, layer, "income");
        attachHoverInteractions(layer, "income");
      }
    }).addTo(mapIncome);

    // compute the full NYC bounds ONCE and reuse
    fullBounds = geojsonLayerTrees.getBounds();
    resetView();

    // make sure maps size correctly if container changes
    setTimeout(() => {
      mapTrees.invalidateSize();
      mapIncome.invalidateSize();
      resetView();
    }, 300);
  }

  // ---------- STYLES & HIGHLIGHT ----------
  function styleBase(feature, variant) {
    const zip = getZipFromFeature(feature);
    const d = zip && dataByZip[zip];

    let fillColor = "#cccccc";
    if (d) {
      if (variant === "trees" && treeColorScale) {
        fillColor = treeColorScale(d.treesPer100);
      }
      if (variant === "income" && incomeColorScale) {
        fillColor = incomeColorScale(d.medianIncome);
      }
    }

    const isSelected = !selectedZip || zip === selectedZip;

    return {
      weight: isSelected ? 1.5 : 0.7,
      opacity: isSelected ? 1 : 0.3,
      color: isSelected ? "#333" : "#aaaaaa",
      fillOpacity: isSelected ? 0.85 : 0.15,
      fillColor
    };
  }

  function styleTrees(feature) {
    return styleBase(feature, "trees");
  }

  function styleIncome(feature) {
    return styleBase(feature, "income");
  }

  // ---------- TOOLTIP ----------
  function attachTooltip(feature, layer, variant) {
    const zip = getZipFromFeature(feature);
    const d = zip && dataByZip[zip];

    if (!d) {
      layer.bindTooltip(
        `<h4>ZIP Code: ${zip || "Unknown"}</h4><p>No data</p>`,
        { sticky: true }
      );
      return;
    }

    const numFmt = d3.format(",.0f");
    const incomeFmt = d3.format(",.0f");
    const oneDec = d3.format(".1f");

    let html;

    if (variant === "trees") {
      html = `
        <h4>ZIP Code: ${d.zip}</h4>
        <p>
          Trees per 100 Residents: <strong>${oneDec(d.treesPer100)}</strong><br/>
          Number of Trees: <strong>${numFmt(d.treeCount)}</strong><br/>
          Population: <strong>${numFmt(d.population)}</strong><br/>
          ${d.goodPct != null ? `Trees in Good Health: <strong>${oneDec(d.goodPct)}%</strong><br/>` : ""}
          ${d.fairPct != null ? `Trees in Fair Health: <strong>${oneDec(d.fairPct)}%</strong><br/>` : ""}
          ${d.poorPct != null ? `Trees in Poor Health: <strong>${oneDec(d.poorPct)}%</strong>` : ""}
        </p>
      `;
    } else {
      html = `
        <h4>ZIP Code: ${d.zip}</h4>
        <p>
          Median Household Income: <strong>$${incomeFmt(d.medianIncome)}</strong>
        </p>
      `;
    }

    layer.bindTooltip(html, { sticky: true, direction: "auto" });
  }

  // ---------- HOVER + CLICK ----------
  function attachHoverInteractions(layer, variant) {
    layer.on({
      mouseover: function (e) {
        const l = e.target;
        l.setStyle({
          weight: 2,
          color: "#000",
          fillOpacity: 0.95
        });
        if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
          l.bringToFront();
        }
      },
      mouseout: function (e) {
        if (variant === "trees" && geojsonLayerTrees) {
          geojsonLayerTrees.resetStyle(e.target);
        } else if (geojsonLayerIncome) {
          geojsonLayerIncome.resetStyle(e.target);
        }
      },
      click: function (e) {
        const feature = e.target.feature;
        const zip = getZipFromFeature(feature);
        if (!zip) return;

        const input = document.getElementById("zipSearch");
        if (selectedZip === zip) {
          // clicking same ZIP again -> unselect & zoom all the way back out
          selectedZip = null;
          if (input) input.value = "";
          clearSuggestions();
          resetView();
        } else {
          if (input) input.value = zip;
          clearSuggestions();
          zoomToZip(zip);
        }
      }
    });
  }

  // ---------- SEARCH UI ----------
  function setupZipSearch() {
    const input = document.getElementById("zipSearch");
    const suggestions = document.getElementById("zipSuggestions");

    function renderSuggestions(matches) {
      if (!matches.length) {
        suggestions.innerHTML = '<div class="no-match">No matches</div>';
        return;
      }
      suggestions.innerHTML = matches
        .map(z => `<div class="suggestion" data-zip="${z}">${z}</div>`)
        .join("");
    }

    input.addEventListener("input", () => {
      const term = input.value.trim();
      if (!term) {
        clearSuggestions();
        selectedZip = null;
        resetView();
        return;
      }
      const matches = allZips.filter(z => z.includes(term));
      renderSuggestions(matches);
    });

    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const val = input.value.trim();
        if (!val) {
          selectedZip = null;
          clearSuggestions();
          resetView();
          return;
        }
        if (allZips.includes(val)) {
          clearSuggestions();
          if (selectedZip === val) {
            selectedZip = null;
            input.value = "";
            resetView();
          } else {
            zoomToZip(val);
          }
        }
      }
    });

    suggestions.addEventListener("click", (e) => {
      const div = e.target.closest(".suggestion");
      if (!div) return;
      const zip = div.dataset.zip;
      if (!zip) return;

      if (input) input.value = zip;
      clearSuggestions();

      if (selectedZip === zip) {
        selectedZip = null;
        input.value = "";
        resetView();
      } else {
        zoomToZip(zip);
      }
    });

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".zip-search-wrapper")) {
        clearSuggestions();
      }
    });
  }

  function clearSuggestions() {
    const suggestions = document.getElementById("zipSuggestions");
    if (suggestions) suggestions.innerHTML = "";
  }

  // ---------- VIEW / ZOOM ----------
  function resetView() {
    if (fullBounds) {
      // zoom to full NYC bounds (all ZIPs)
      mapTrees.fitBounds(fullBounds);
      mapIncome.fitBounds(fullBounds);
    } else {
      // fallback if bounds not ready yet
      mapTrees.setView(NYC_CENTER, NYC_ZOOM);
      mapIncome.setView(NYC_CENTER, NYC_ZOOM);
    }

    if (geojsonLayerTrees) geojsonLayerTrees.setStyle(styleTrees);
    if (geojsonLayerIncome) geojsonLayerIncome.setStyle(styleIncome);
  }

  function zoomToZip(zip) {
    selectedZip = zip;

    if (!geojsonLayerTrees) return;

    let targetLayer = null;
    geojsonLayerTrees.eachLayer(layer => {
      const fZip = getZipFromFeature(layer.feature);
      if (fZip === zip) targetLayer = layer;
    });

    if (!targetLayer) return;

    const bounds = targetLayer.getBounds();
    const options = { maxZoom: 13, padding: [10, 10] };
    mapTrees.fitBounds(bounds, options);
    mapIncome.fitBounds(bounds, options);

    if (geojsonLayerTrees) geojsonLayerTrees.setStyle(styleTrees);
    if (geojsonLayerIncome) geojsonLayerIncome.setStyle(styleIncome);
  }
</script>
</body>
</html>
